# Manage namespaces and utility functions

#' @importFrom magrittr %>%
#' @importFrom data.table := fifelse
NULL

.makeRegions_env <- new.env(parent = emptyenv())

.makeRegions_env$configFile <- NULL
.makeRegions_env$logFile <- NULL

#' Set config and log file paths for makeRegions
#'
#' These functions set and create the files for config (.json) and log (.log)
#' files used by the \code{makeRegions} process.
#'
#' \itemize{
#'   \item \code{setConfig()} sets the file path for the configuration file.
#'   \item \code{setLog()} sets the file path for the log file.
#' }
#'
#' @param file Character string specifying the file path. The containing
#'   directory will be created if it does not exist. Use \code{NULL} to unset.
#'
#' @returns No return value, called for side effects.
#' @export
#' @rdname makeRegionsFiles
#'
#' @examples
#' \dontrun{
#' setConfig("~/project/config.json")
#' setLog("~/project/console.log")
#' }
setConfig <- function(file) {
  if (!is.null(file)) {
    stopifnot(is.character(file), length(file) == 1)
    dir_path <- dirname(file)
    if (!dir.exists(dir_path)) {
      dir.create(dir_path, recursive = TRUE, showWarnings = FALSE)
    }
    if(!file.exists(file)) {
      file.create(file)
    }
    writeLines("{}", file) # initiate json
  }
  .makeRegions_env$configFile <- file
}

#' @export
#' @rdname makeRegionsFiles
setLog <- function(file) {
  if (!is.null(file)) {
    stopifnot(is.character(file), length(file) == 1)
    dir_path <- dirname(file)
    if (!dir.exists(dir_path)) {
      dir.create(dir_path, recursive = TRUE, showWarnings = FALSE)
    }
    if(!file.exists(file)) {
      file.create(file)
    }
  }
  .makeRegions_env$logFile <- file
}

write_config <- function(caller_name, params) {
  # write the parameters of the function into the config file
  if (!is.null(.makeRegions_env$configFile)) {
    config <- jsonlite::read_json(.makeRegions_env$configFile)
    config[[caller_name]] <- params
    jsonlite::write_json(config, path = .makeRegions_env$configFile,
                         pretty = TRUE, auto_unbox = TRUE)
  }
}

# caller_name: function name
# args: named list of parameter and values
start_log <- function(caller_name, args) {
  if (!is.null(.makeRegions_env$logFile)) {
    log_con <- file(.makeRegions_env$logFile, open = "at")

    sink(log_con, type = "output", append = TRUE)
    sink(log_con, type = "message", append = TRUE)

    timestamp <- format(Sys.time(), "%Y-%m-%d %H:%M:%S")
    message(paste0("\n[", timestamp, "]"))

    args <- args[!vapply(args, is.null, FUN.VALUE = logical(1))]
    args <- paste(
      vapply(names(args), function(n) {
        val <- args[[n]]
        # Keep it short for large objects
        if (is.character(val) || is.numeric(val) || is.logical(val)) {
          paste0(n, " = ", toString(val))
          } else {
            paste0(n, " = <", class(val)[1], ">")
            }
        }, FUN.VALUE = character(1)),
      collapse = ", ")
    message(paste0(caller_name, "(", args, ")"))

    return(function() {
      sink(type = "output")
      sink(type = "message")
      close(log_con)
    })
  }
}


#' Utility function: output nomenclature
#'
#' Creates a standard name based on given parameters.
#' Originally created for use with make_windows, hence parameters like
#' input_file, upstream and downstream will be ignored.
#'
#' @param enclosing_dir Indicates in which dir the file will should be.
#' @param pars A named list of arguments. The names correspond to the parameters of the values.
#' @param ext Extension.
#'
#' @returns A character vector as file path generated by the parameters.
#' @export
#'
#' @examples
#' pars$make_windows$path_to_output <- name_output_with(out_dir, pars$make_windows, ".bed")
name_output_with <- function(enclosing_dir, pars, ext) {
  stopifnot(c("input_file", "upstream", "downstream") %in% names(pars))

  filebase <- sub("\\.[^.]*$", "", basename(pars$input_file))

  # upstream & downstream first
  updown <- c(
    sprintf("%sup", pars$upstream),
    sprintf("%sdown", pars$downstream)
  )

  extra_keys <- setdiff(names(pars), c("input_file", "upstream", "downstream", "path_to_output"))
  extra_parts <- as.character(pars[extra_keys])
  extra_parts <- extra_parts[extra_parts != ""]  # remove empty args

  # Combine all parts
  filename <- paste(c(filebase, updown, extra_parts), collapse = "_")

  # Add .bed extension
  filename <- paste0(filename, ext)
  file.path(enclosing_dir, filename)
}


